##测试目录结构##
![test catalogue](..\ref\pic\test_catalogue.png)

##测试流程说明##
###仿真测试###
1、先进行单周期CPU实验的测试代码测试
>*测试通过说明单周期包含的指令基本没有错误，整个流水线CPU可以基本跑起来了*
>
>*使用测试代码：single cycle目录测试代码Start.S*
>
>*注意：由于单周期CPU对于延迟槽进行了忽略，其测试代码也未加入延迟槽指令，而流水线CPU考虑了延迟槽情况，因此需要对单周期测试代码的每一条跳转指令后加nop指令，来作为延迟槽指令。该目录测试代码已经添加了nop指令。*

2、再进行各个部件功能的测试
>*测试通过说明各个部件功能执行正常，则可以进行下一阶段的流水线整体代码测试*
>
>*测试部件：乘除法部件、CP0、异常处理（.S）*
>
>*使用测试代码：unit目录测试代码（mul_div测试乘除法部件，cp0_except测试cp0与异常处理）*

3、整体代码测试
>*多次测试用以检测是否存在错误情况，以及各部件是否配合正常。若所有代码均通过仿真测试，则仿真测试通过，可以开始生成bit文件烧录到FPGA板子上进行进一步测试*
>
>*使用测试代码：src目录测试代码*


***注：当使用single-cycle中的start.S测试时，直接使用jackyang的工具（具体见单周期测试文档）；当使用units下的测试用例xxx.S时，用xxx.S中的汇编覆盖start.S中的_reset函数体，之后仍然按单周期测试文档进行测试；当使用src文件夹下的.c文件测试时，参见带cache的测试文档。***

仿真测试流程详见“流水线CPU设计文档-4.1、4.2”

###上板子测试###

由于仿真测试无法真正代表现实状态所有情况，比如时钟问题等。且后期需要在FPGA板子上烧录出CPU，之后在CPU之上跑PA或者操作系统，因此需要知道实际是否运转正常，由此有板子上的测试。

>loader_mem需要.coe文件，而spi flash需要.mcs文件，其文件关系详见“doc/实验总框架”。

**生成.coe文件：使用utils/gen_coe/gen_coe.py文件，使用指令：./gen_coe.py [.c文件目录]，生成出来的.coe文件在utils/gen_coe/ram_init_gen目录下，之后便可以在生成IP核时使用该.coe文件初始化该ip核，CPU再读取存在该ip核上的指令数据，开始执行流程。（具体IP核配置详见“流水线CPU设计文档-4.3”）**

**生成.mcs文件：使用utils/gen_coe/ram_init_gen/Makefile文件，将.c或.s文件拷贝到该目录，清除掉其余的.c与.S文件，使用指令make flash,即可在该目录下生成.mcs文件，之后使用Vivado软件将.mcs文件烧录到FPGA板子上的flash存储区，即可存储该文件.c或者.s文件。（具体详见后期.mcs文件的烧录） -- 目前未写该文档，后期上传**

>目前上板子测试直接在loader_mem的存储区进行读写，将cache存储区作为栈帧区域，因而使用的是其他代码执行流程（流水线CPU设计文档-2.3），即将要执行的代码生成.coe文件，并将该.coe文件初始化到loader_mem中，同时将pc初始地址设置为0xf0000000。

测试方法如下所示：

1、观察七段数码管显示的pc是否是正常执行顺序，以及在最后是否跳转到最终的死循环地址。

2、观察显示屏上是否显示数据以及显示的数据是否是正确的顺序。

>如果两个条件均成立，则测试成功。

Debug方法：

将时钟调整为慢速，查看pc变化情况，是否符合原本的定义，或者调整为查看其它信息，当感觉某一段不正确时可以将时钟暂停来看输出的状态。这里可以在FPGA板子上尽量输出对自己有用的调试信息。





	注：我们板子上开关关联的显示数据：
	-sw15  CPU的reset输入，1为有效，0为无效
	-sw13 ~ sw10 组合用于输出cpu中的各部分信息，常使用的组合：
			0000:IF阶段取出的指令
			0001：IF阶段的指令地址
			0010：读写data的地址
			0011：向内存写入的数据本身
			0100：未定义
			.....
	-sw9~sw8 组合用于产生不同的时钟：
			01:慢速时钟，可以看清七段数码管的变化
			10：快速时钟，用于快速执行完指令，查看指令执行效果


